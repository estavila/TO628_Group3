---
title: "OxFord COVID-19 Data Exploration"
output: html_document
author: "Estefania Avila, Meitong Hu, Egle Klekere, Alla Polishchuk, Jingjing Zhang"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Data Source & Summary

OXFORD COVID-19 GOVERNMENT RESPONSE TRACKER: aims to track and compare government responses to the coronavirus outbreak worldwide rigorously and consistently. We can analyze how specific government measures affect outcomes in terms of COVID cases and deaths.
https://www.bsg.ox.ac.uk/research/research-projects/oxford-covid-19-government-response-tracker

#### 13 Measures Tracked by Oxford:

* S1_School closing
* S2_Workplace closing
* S3_Cancel public events
* S4_Close public transport
* S5_Public information campaigns
* S6_Restrictions on internal movement
* S7_International travel controls
* S8_Fiscal measures
* S9_Monetary measures
* S10_Emergency investment in health care
* S11_Investment in Vaccines
* S12_Testing framework
* S13_Contact tracing

OxCGRT collects publicly available information on 13 indicators of government response (S1-S13). Nine of the indicators (S1-S7, S12 and S13) take policies such as school closures, travel bans, etc. are recorded on an ordinal scale; the remainder (S8-S11) are financial indicators such as fiscal or monetary measures.

This endpoint provides JSON by with country stringency data, confirmed cases and deaths on a day by day basis as collected by our data collection team. The stringency_actual field is the daily calculated data. The stringency field is a convenience field for visualisations which holds previous day data (up to 7 days) if data in unavailable for a given day.

#### Other data in dataset:

* ConfirmedCases
* ConfirmedDeaths
* StringencyIndex

Oxford has a StringencyIndex that measures how stringent each government has reacted. I thought, maybe we can introduce Proactivity index - how many measures country has introduced before first ConfirmedCase and first ConfirmedDeath. I assume this affects the outcomes as well. Then one of our questiond would be: What has been more effective stringency or proactivity?

Interesting analysis of Oxford data:
https://www.bsg.ox.ac.uk/research/research-projects/oxford-covid-19-government-response-tracker?ref=researchstash

White Paper on Data:
https://www.bsg.ox.ac.uk/sites/default/files/2020-04/BSG-WP-2020-031-v4.0_0.pdf



## Data Exploration
### Read File
Read file in.Noticed it has a lot of "Notes" columns used to supply source of change in variable.

```{r ,}
data = read.csv("OxCGRT_Download_080420_161822_Full.csv")
names(data)
```



#### Get Top 30 Countries
Top 30 is based on the number of Confirmed Cases on 04-08-2020. This can be modified.
```{r ,}
# look at the rows with the date 2020-04-08
data_0408 = subset(data, data$Date == 20200408)
# order data in descending order based on num cases and deaths
data_0408 = data_0408[order(-data_0408$ConfirmedCases, -data_0408$ConfirmedDeaths),]
# data_04 = data_0408[data_0408$ConfirmedCases > 0,]
# data_04 = data_04[, c('CountryName', 'ConfirmedCases')]
# str(data_04)
# top = head(data_04,30)
# top$CountryName = factor(top$CountryName)
# str(top)
# print(top)
# print(data_04$ConfirmedCases)
# print(levels(factor(data_0408$CountryName)))


# take the levels of first 30 rows of the CountryName column
top30 = levels(factor(head(data_0408,30)$CountryName))

top30
```

#### Filter data to only include Top 30 Countries
```{r ,}
# take the subset of data related to top 30 countries
df_top30 = subset(data, CountryName %in% top30)
df_top30 = subset(df_top30, df_top30$Date <= 20200408)
# drop unused levels from all factors
df_top30[] = lapply(df_top30, function(x) if(is.factor(x)) factor(x) else x)
```

#### Separate or remove excess columns
The Notes and General columns do not pertain to our prediction model. We will also only be using the Display Stringency Index as it is more complete.
```{r ,}
# find columns with Notes or General in name
Notes = c(grep( "Notes" , names( df_top30 ) ))
General = c(grep( "General" , names( df_top30 ) ))
# save notes and general as separate df's
df_notes = subset(df_top30, select = Notes )
df_general = subset( df_top30, select = General )
# remove notes and general columns from main df
df_top30 = subset( df_top30, select = -c(Notes, General))

# remove duplicate stringency index
df_top30 = subset(df_top30, select = -c(StringencyIndex))

str(df_top30)
summary(df_top30)
df = df_top30
```

#### Deal with NAs and NULLs
For most if not all measures, NA or NULL values were replaced with the most recent non-zero value for that country when possible, else zero
```{r ,}
# need to figure out how to make these take last non-zero value
df$ConfirmedCases[df$Date == 20200101 & is.na(df$ConfirmedCases)] <- 0



```

#### Dealing with General vs Targetted
Data includes targeted and general measures. Should we be treating them differently?
```{r ,}
#


```

#### Converting Date Format
```{r ,}
# turn date column into date format
df$Date <- as.Date(as.character(df$Date),"%Y%m%d")
```

### Flatten Data
#### Separate Flattening Columns
Some columns are informational and do not need to be flattened. Some measures need to be summed to that point. Others can just take the face value?
```{r ,}
info = c("Date", "CountryName", "CountryCode", "ConfirmedCases", "ConfirmedDeaths") #, "StringencyIndexForDisplay", "X")
measures = names(df)[!(names(df) %in% info)]
measures
```

Flatten Data into new DataFrame
```{r ,}
# create empty data frame
df_flat <- data.frame(Date=as.Date(character()),
                      Day = integer(),
                     CountryName=character(), 
                     CountryCode=character(),
                     S1_School.closing = integer(),
                     S2_Workplace.closing = integer(),
                     S3_Cancel.public.events = integer(),
                     S4_Close.public.transport = integer(),
                     S5_Public.information.campaigns = integer(),
                     S6_Restrictions.on.internal.movement = integer(),
                     S7_International.travel.controls = integer(),
                     S8_Fiscal.measures = double(),
                     S9_Monetary.measures = double(),
                     S10_Emergency.investment.in.health.care = double(),
                     S11_Investment.in.Vaccines = double(),
                     S12_Testing.framework = integer(),
                     S13_Contact.tracing = integer(),
                     StringencyIndexForDisplay = double(),
                     ConfirmedCases = integer(),
                     ConfirmedDeaths = integer(),
                     stringsAsFactors=FALSE) 

str(df_flat)
```


```{r ,}
## FLATTENING FOR ONE Country to debug only 
# for each country in the top 30
# for (country in top30) {
#   # subset of data only for that country
#   df_country = subset(df, CountryName == country)
#   cc = levels(factor(df_country$CountryCode))
#   print(country)
#   if (country == "China"){
#     
#     #Take care of null values for Confirmed Cases
#     df_country$ConfirmedCases = na.locf(with(df_country, ifelse(df_country$ConfirmedCases == 'NA', NA_real_, df_country$ConfirmedCases)), fromLast = FALSE)
#     
#     x = Position(function(x) x > 100, df_country$ConfirmedCases) - 1
#     df_country_reset = tail(df_country, -x)
#     c_dates = sort(unique(df_country_reset$Date, incomparables = FALSE))
#     c_dates = c_dates[seq(1, length(c_dates), 7)]
#     for (d in seq_along(c_dates)){
#       print(c_dates[d])
#       df_date = subset(df_country_reset, Date <= c_dates[d])
#       cols = colSums(df_date[measures], na.rm = TRUE)
#        
#       df_flat <- rbind(df_flat, data.frame(Date = c_dates[d],
#                       Day = as.integer(c_dates[d]-c_dates[1]),
#                        CountryName = country,
#                        CountryCode = cc,
#                        S1_School.closing = as.integer(cols['S1_School.closing']),
#                        S2_Workplace.closing = as.integer(cols['S2_Workplace.closing']),
#                        S3_Cancel.public.events = as.integer(cols['S3_Cancel.public.events']),
#                        S4_Close.public.transport = as.integer(cols['S4_Close.public.transport']),
#                        S5_Public.information.campaigns = as.integer(cols['S5_Public.information.campaigns']),
#                        S6_Restrictions.on.internal.movement = as.integer(cols['S6_Restrictions.on.internal.movement']),
#                        S7_International.travel.controls = as.integer(cols['S7_International.travel.controls']),
#                        S8_Fiscal.measures = cols['S8_Fiscal.measures'],
#                        S9_Monetary.measures = cols['S9_Monetary.measures'],
#                        S10_Emergency.investment.in.health.care = cols['S10_Emergency.investment.in.health.care'],
#                        S11_Investment.in.Vaccines = cols['S11_Investment.in.Vaccines'],
#                        S12_Testing.framework = as.integer(cols['S12_Testing.framework']),
#                        S13_Contact.tracing = as.integer(cols['S13_Contact.tracing']),
#                        StringencyIndexForDisplay = cols['StringencyIndexForDisplay'],
#                        ConfirmedCases = as.integer(df_date$ConfirmedCases[df_date$Date == c_dates[d]]),
#                        ConfirmedDeaths = as.integer(df_date$ConfirmedDeaths[df_date$Date == c_dates[d]])))
#     }
#   }
# }
# 
# str(df_flat)

```

###### 
```{r ,}
## FLATTENING FOR ALL 
# some countries have an issue here...working on it
library(zoo)
# for each country in the top 30
for (country in top30) {
  # subset of data only for that country
  df_country = subset(df, CountryName == country)
  cc = levels(factor(df_country$CountryCode))
  print(country)
  
  df_country$ConfirmedCases = na.locf(with(df_country, ifelse(df_country$ConfirmedCases == 'NA', NA_real_, df_country$ConfirmedCases)), fromLast = FALSE)

  x = Position(function(x) x > 0, df_country$ConfirmedCases)
  df_country_reset = tail(df_country, -x)
  c_dates = sort(unique(df_country_reset$Date, incomparables = FALSE))
  c_dates = c_dates[seq(1, length(c_dates), 7)]
  print(c_dates[1])
  for (d in seq_along(c_dates)){
    #print(c_dates[d])
    df_date = subset(df_country_reset, Date <= c_dates[d])
    cols = colSums(df_date[measures], na.rm = TRUE)

    # add date and country to dataframe
    df_flat <- rbind(df_flat, data.frame(Date = c_dates[d],
                    Day = as.integer(c_dates[d]-c_dates[1]),
                     CountryName = country,
                     CountryCode = cc,
                     S1_School.closing = as.integer(cols['S1_School.closing']),
                     S2_Workplace.closing = as.integer(cols['S2_Workplace.closing']),
                     S3_Cancel.public.events = as.integer(cols['S3_Cancel.public.events']),
                     S4_Close.public.transport = as.integer(cols['S4_Close.public.transport']),
                     S5_Public.information.campaigns = as.integer(cols['S5_Public.information.campaigns']),
                     S6_Restrictions.on.internal.movement = as.integer(cols['S6_Restrictions.on.internal.movement']),
                     S7_International.travel.controls = as.integer(cols['S7_International.travel.controls']),
                     S8_Fiscal.measures = cols['S8_Fiscal.measures'],
                     S9_Monetary.measures = cols['S9_Monetary.measures'],
                     S10_Emergency.investment.in.health.care = cols['S10_Emergency.investment.in.health.care'],
                     S11_Investment.in.Vaccines = cols['S11_Investment.in.Vaccines'],
                     S12_Testing.framework = as.integer(cols['S12_Testing.framework']),
                     S13_Contact.tracing = as.integer(cols['S13_Contact.tracing']),
                     StringencyIndexForDisplay = cols['StringencyIndexForDisplay'],
                     ConfirmedCases = as.integer(df_date$ConfirmedCases[df_date$Date == c_dates[d]]),
                     ConfirmedDeaths = as.integer(df_date$ConfirmedDeaths[df_date$Date == c_dates[d]])))
  }

}

str(df_flat)

```

### Linear Regression
```{r}
#Replace some values to unify the units.
df_flat$S11_Investment.in.Vaccines[df_flat$S11_Investment.in.Vaccines>1000]<-with(df_flat,S11_Investment.in.Vaccines[df_flat$S11_Investment.in.Vaccines>1000]*0.000001)
df_flat$S11_Investment.in.Vaccines<-round(df_flat$S11_Investment.in.Vaccines,1)

df_flat$S10_Emergency.investment.in.health.care[df_flat$S10_Emergency.investment.in.health.care>100000]<-with(df_flat,S10_Emergency.investment.in.health.care[df_flat$S10_Emergency.investment.in.health.care>100000]*0.000001)
df_flat$S10_Emergency.investment.in.health.care<-round(df_flat$S10_Emergency.investment.in.health.care,1)


# Creating a column named 'Death Rate' as the dependent variable.
df_flat$DeathRate<-round(df_flat$ConfirmedDeaths/df_flat$ConfirmedCases,3)
library(lmtest)
library(car)


# Run Linear Regression model without removing outliers. 3 variables are statistically significant, but only 1 of them are closing to '0', two others are greater than 0.01.
df_flat_model<-lm(DeathRate ~ S1_School.closing+S2_Workplace.closing+S3_Cancel.public.events+S4_Close.public.transport+S5_Public.information.campaigns+S6_Restrictions.on.internal.movement+S7_International.travel.controls, data=df_flat )
summary(df_flat_model)
residualPlots(df_flat_model)

# Run Linear Regression excluding outliers (Iran). The output shows that 3 variables (closing workplace, closing public transport, and public information campaigns) are statistically significant to Death Rate and the p-values are closing to '0'. Also, this could improve the Adjusted R-squared from 0.1615 to 0.4889.
df_flat_2<-df_flat[!(df_flat$CountryName=="Iran"),]
df_flat_model_2<-lm(DeathRate ~ S1_School.closing+S2_Workplace.closing+S3_Cancel.public.events+S4_Close.public.transport+S5_Public.information.campaigns+S6_Restrictions.on.internal.movement+S7_International.travel.controls+S10_Emergency.investment.in.health.care+S11_Investment.in.Vaccines, data=df_flat_2 )
summary(df_flat_model_2)
residualPlots(df_flat_model_2)
  
```



### Explore Notes Columns
To explore the notes data, we just peaked into one of the columns to see what kind of announcements they are using.
```{r ,}
names(df_notes)
str(df_notes)
levels(df_notes$S1_Notes)[1:5]
```

### Explore Genral Columns
To explore the general, we just peaked into one of the columns to see what kind of announcements they are using.
```{r ,}
names(df_general)
str(df_general)
levels(df_general$S1_IsGeneral)[1:20]
```

## Potential Questions to Explore:

* Which measures were most effective for which countries?
* Predict number of cases? deaths? 